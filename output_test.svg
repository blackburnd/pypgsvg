<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 12.2.1 (20241206.2353)
 -->
<!-- Pages: 1 -->
<svg id="main-svg" width="119pt" height="80pt"
 viewBox="0.00 0.00 118.75 79.50" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="main-erd-group" class="graph" transform="scale(1 1) rotate(0) translate(4 75.5)" style="pointer-events: all;">
<polygon fill="white" stroke="none" points="-4,4 -4,-75.5 114.75,-75.5 114.75,4 -4,4"/>
<!-- test -->
<g id="test" class="node">
<title>test</title>
<polygon fill="white" stroke="black" points="110.75,-71.5 0,-71.5 0,0 110.75,0 110.75,-71.5"/>
<polygon fill="#e8a8a8" stroke="none" points="8,-32.75 8,-67.5 102.75,-67.5 102.75,-32.75 8,-32.75"/>
<polygon fill="none" stroke="black" points="8,-32.75 8,-67.5 102.75,-67.5 102.75,-32.75 8,-32.75"/>
<text text-anchor="start" x="35.88" y="-39.7" font-family="Sans-Serif" font-size="24.00">test</text>
<polygon fill="none" stroke="black" points="8,-4 8,-32.75 102.75,-32.75 102.75,-4 8,-4"/>
<text text-anchor="start" x="13" y="-10.65" font-family="Sans-Serif" font-size="18.00">id (integer)</text>
</g>
</g>
<script id="graph-data" type="application/json">{"tables": {"test": {"defaultColor": "#E8A8A8", "highlightColor": "#fe9191", "desaturatedColor": "#cbc4c4", "edges": []}}, "edges": {}, "defaultColor": "#cccccc", "highlightColor": "#ff0000"}</script>

    <defs>
        <style type="text/css">
            #main-svg { overflow: visible; }
            #overlay-container-div {
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                pointer-events: none;
                font-family: system-ui, -apple-system, sans-serif;
                z-index: 9999;
            }
            .metadata-box, .miniature-box, .instructions {
                position: absolute;
                z-index: 9999;
                pointer-events: auto;
                box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
                border-radius: 4px;
            }
            .metadata-box {
                top: 10px;
                right: 20px;
                background: lightyellow;
                border: 1px solid #000;
                padding: 10px;
                font-family: monospace;
                font-size: 14px;
                line-height: 1.5;
                max-width: 300px;
            }
            .miniature-box {
                position: absolute;
                top: 10px;
                left: 20px;
                background: white;
                border: 1px solid #ccc;
                padding: 10px;
                z-index: 10000;
                pointer-events: auto;
            }
            .miniature-title {
                font-size: 12px;
                font-weight: bold;
                margin-bottom: 5px;
                text-align: center;
                color: #333;
            }
            .miniature-container {
                position: relative;
                cursor: crosshair;
                border: 1px solid #ccc;
                max-width: 100%;
                max-height: 100%;
                overflow: hidden;
            }
            .miniature-container img {
                max-width: 100%;
                height: auto;
                display: block;
            }
            .viewport-indicator {
                position: absolute;
                border: 2px solid red;
                background-color: rgba(255,0,0,0.2);
                pointer-events: auto;
                opacity: 0.8;
                transition: all 0.1s ease;
                box-sizing: border-box;
                cursor: grab;
            }
            .viewport-indicator.dragging {
                cursor: grabbing;
            }
            .instructions {
                bottom: 10px;
                right: 20px;
                font-size: 11px;
                color: #666;
                background-color: rgba(255,255,255,0.7);
                padding: 3px 6px;
            }
            #main-svg.grabbing {
                cursor: grabbing;
            }
            .node, .edge {
                pointer-events: auto;
                cursor: pointer;
            }
        </style>
    </defs>
    
    <foreignObject id="overlay-container" x="0" y="0" width="100%" height="100%" pointer-events="none">
        <div xmlns="http://www.w3.org/1999/xhtml" id="overlay-container-div" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; font-family: system-ui, -apple-system, sans-serif; z-index: 9999;">
            <div class='metadata-box'><div>Source: Unknown</div><div>File Size: Unknown</div><div>Generated: 2025-07-23 11:09:24</div><div>Tables: 1</div><div>Columns: 1</div><div>Foreign Keys: 0</div><div>Connections: 0</div></div>
    <div class="instructions">
        ðŸ’¡ Drag to pan â€¢ Scroll to zoom â€¢ Click map to navigate â€¢ Click tables/edges to highlight â€¢ ESC/R to reset
    </div>
    
        </div>
    </foreignObject>
    <script type="text/javascript"><![CDATA[
document.addEventListener('DOMContentLoaded', () => {

    const svg = document.getElementById('main-svg');
    const mainGroup = document.getElementById('main-erd-group');
    const miniatureContainer = document.getElementById('miniature-container');
    const viewportIndicator = document.getElementById('viewport-indicator');
    const overlayContainer = document.getElementById('overlay-container');
    const graphDataElement = document.getElementById('graph-data');

    if (!svg || !mainGroup || !overlayContainer || !graphDataElement) {
        return;
    }

    if (!miniatureContainer || !viewportIndicator) {

    }

    const graphData = JSON.parse(graphDataElement.textContent);
    const { tables, edges } = graphData;

    // --- State variables
    let initialTx = 0, initialTy = 0, initialS = 1; // Transform from Graphviz
    let userTx = 0, userTy = 0, userS = 1; // User-applied transform (pan/zoom)

    let isPanning = false;
    let startX = 0, startY = 0;
    let mouseDownStartX = 0, mouseDownStartY = 0;
    let dragThreshold = 5; // Pixel threshold before panning starts

    let isDraggingIndicator = false;
    let indicatorStartX = 0, indicatorStartY = 0;

    let highlightedElementId = null; // To track the currently highlighted table/edge

    // --- INITIALIZATION ---

    // Parse the initial transform applied by Graphviz to the main group
    const parseTransform = (transform) => {
        const result = { tx: 0, ty: 0, s: 1 };
        if (!transform) return result;
        const translateMatch = transform.match(/translate\(([^,)]+),([^,)]+)\)/);
        if (translateMatch) {
            result.tx = parseFloat(translateMatch[1]);
            result.ty = parseFloat(translateMatch[2]);
        }
        const scaleMatch = transform.match(/scale\(([^)]+)\)/);
        if (scaleMatch) {
            result.s = parseFloat(scaleMatch[1]);
        }
        return result;
    };

    const initialTransform = parseTransform(mainGroup.getAttribute('transform'));
    initialTx = initialTransform.tx;
    initialTy = initialTransform.ty;
    initialS = initialTransform.s;

    // --- CORE FUNCTIONS ---

    // Get the untransformed bounding box of the main diagram content
    const getMainERDBounds = () => {
        return mainGroup.getBBox();
    };

    // Apply the combined (initial + user) transform to the main group
    const applyTransform = () => {
        const finalS = userS * initialS;
        const finalTx = (userTx * initialS) + initialTx;
        const finalTy = (userTy * initialS) + initialTy;
        mainGroup.setAttribute('transform', `translate(${finalTx} ${finalTy}) scale(${finalS})`);
        // Update indicator after transform
        requestAnimationFrame(updateViewportIndicator);
    };

    // Update the red box on the minimap to show the current viewport
    const updateViewportIndicator = () => {
        if (!viewportIndicator) return;

        const mainBounds = getMainERDBounds();
        if (mainBounds.width === 0 || mainBounds.height === 0) return;

        const ctm = mainGroup.getScreenCTM();
        if (!ctm) return;
        const invCtm = ctm.inverse();

        // Find viewport corners in the main group's coordinate system
        const pt1 = svg.createSVGPoint();
        pt1.x = 0;
        pt1.y = 0;
        const svgPt1 = pt1.matrixTransform(invCtm);

        const pt2 = svg.createSVGPoint();
        pt2.x = window.innerWidth;
        pt2.y = window.innerHeight;
        const svgPt2 = pt2.matrixTransform(invCtm);

        const visibleWidth = svgPt2.x - svgPt1.x;
        const visibleHeight = svgPt2.y - svgPt1.y;

        // Calculate relative position and size
        const relLeft = (svgPt1.x - mainBounds.x) / mainBounds.width;
        const relTop = (svgPt1.y - mainBounds.y) / mainBounds.height;
        const relWidth = visibleWidth / mainBounds.width;
        const relHeight = visibleHeight / mainBounds.height;

        // Apply and clamp values
        viewportIndicator.style.left = `${Math.max(0, Math.min(1, relLeft)) * 100}%`;
        viewportIndicator.style.top = `${Math.max(0, Math.min(1, relTop)) * 100}%`;
        viewportIndicator.style.width = `${Math.max(0, Math.min(1, relWidth)) * 100}%`;
        viewportIndicator.style.height = `${Math.max(0, Math.min(1, relHeight)) * 100}%`;
    };

    // Combined handler for any event that changes the viewport
    const onViewportChange = () => {
        requestAnimationFrame(updateViewportIndicator);
    };

    // --- HIGHLIGHTING ---
    const setElementColor = (elem, color, isHighlighted = false) => {
        if (!elem) {
            return;
        }

        if (elem.classList && elem.classList.contains('node')) {
            const mainPath = elem.querySelector('path');
            if (mainPath) {
                mainPath.setAttribute('fill', color);
                if (isHighlighted) {
                    mainPath.setAttribute('stroke-width', '6');
                    mainPath.setAttribute('stroke', color);
                } else {
                    mainPath.setAttribute('stroke-width', '1');
                    mainPath.setAttribute('stroke', 'black');
                }
            }

            const polygons = elem.querySelectorAll('polygon');
            polygons.forEach(polygon => {
                polygon.setAttribute('fill', color);
                if (isHighlighted) {
                    polygon.setAttribute('stroke-width', '6');
                    polygon.setAttribute('stroke', color);
                } else {
                    polygon.setAttribute('stroke-width', '1');
                    polygon.setAttribute('stroke', 'black');
                }
            });
        }

        if (elem.classList && elem.classList.contains('edge')) {
            const edgePath = elem.querySelector('path');
            if (edgePath) {
                edgePath.setAttribute('stroke', color);
                if (isHighlighted) {
                    edgePath.setAttribute('stroke-width', '6');
                } else {
                    edgePath.setAttribute('stroke-width', '3');
                }
            }
        }
    };

    const highlightElements = (tableIds, edgeIds) => {
        tableIds.forEach(id => {
            const tableElement = document.getElementById(id);
            if (tableElement) {
                setElementColor(tableElement, tables[id].highlightColor, true);
            }
        });
        edgeIds.forEach(id => {
            const edgeElement = document.getElementById(id);
            if (edgeElement) {
                setElementColor(edgeElement, edges[id].highlightColor, true);
            }
        });

        Object.keys(tables).forEach(id => {
            if (!tableIds.includes(id)) {
                const tableElement = document.getElementById(id);
                if (tableElement) {
                    setElementColor(tableElement, tables[id].desaturatedColor, false);
                }
            }
        });
        Object.keys(edges).forEach(id => {
            if (!edgeIds.includes(id)) {
                const edgeElement = document.getElementById(id);
                if (edgeElement) {
                    setElementColor(edgeElement, edges[id].desaturatedColor, false);
                }
            }
        });
    };

    const clearAllHighlights = () => {
        Object.keys(tables).forEach(id => {
            const tableElement = document.getElementById(id);
            if (tableElement) {
                setElementColor(tableElement, tables[id].defaultColor, false);
            }
        });
        Object.keys(edges).forEach(id => {
            const edgeElement = document.getElementById(id);
            if (edgeElement) {
                setElementColor(edgeElement, edges[id].defaultColor, false);
            }
        });
        highlightedElementId = null;
    };

    // --- USER ACTIONS ---

    // Reset pan and zoom to the initial state
    const resetZoom = () => {
        userTx = 0;
        userTy = 0;
        userS = 1;
        clearAllHighlights(); // Also clear highlights on reset
        applyTransform();
    };
    const zoomToPoint = (targetX, targetY, zoomLevel = userS) => {
        userS = zoomLevel;
        const finalS = userS * initialS;
        const pt = svg.createSVGPoint();
        pt.x = window.innerWidth / 2;
        pt.y = window.innerHeight / 2;
        const svgCenterPt = pt.matrixTransform(svg.getScreenCTM().inverse());
        const finalTx = svgCenterPt.x - targetX * finalS;
        const finalTy = svgCenterPt.y - targetY * finalS;
        userTx = (finalTx - initialTx) / initialS;
        userTy = (finalTy - initialTy) / initialS;
        applyTransform();
    };


    // --- EVENT LISTENERS ---

    svg.addEventListener('click', (event) => {
        let clickedElement = event.target;
        let tableId = null;
        let edgeId = null;

        while (clickedElement && clickedElement !== svg) {
            if (clickedElement.classList && clickedElement.classList.contains('node')) {
                tableId = clickedElement.id;
                break;
            }

            if (clickedElement.classList && clickedElement.classList.contains('edge')) {
                edgeId = clickedElement.id;
                break;
            }

            clickedElement = clickedElement.parentElement;
        }

        if (tableId && tables[tableId]) {
            event.preventDefault();
            event.stopPropagation();

            if (highlightedElementId === tableId) {
                clearAllHighlights();
            } else {
                clearAllHighlights();
                highlightedElementId = tableId;
                const connectedEdges = tables[tableId].edges;
                const connectedTables = [tableId, ...connectedEdges.map(edgeId => edges[edgeId].tables).flat()];
                const uniqueTables = [...new Set(connectedTables)];
                highlightElements(uniqueTables, connectedEdges);
            }
            return;
        }

        if (edgeId && edges[edgeId]) {
            event.preventDefault();
            event.stopPropagation();

            if (highlightedElementId === edgeId) {
                clearAllHighlights();
            } else {
                clearAllHighlights();
                highlightedElementId = edgeId;
                const connectedTables = edges[edgeId].tables;
                highlightElements(connectedTables, [edgeId]);
            }
            return;
        }
    });

    // Handle dragging the viewport indicator
    if (viewportIndicator) {
        viewportIndicator.addEventListener('mousedown', (event) => {
            event.stopPropagation(); // Prevent main canvas panning
            isDraggingIndicator = true;
            indicatorStartX = event.clientX;
            indicatorStartY = event.clientY;
            viewportIndicator.classList.add('dragging');
        });
    }

    // Handle minimap clicks for zoom-to-point
    if (miniatureContainer) {
        miniatureContainer.addEventListener('click', (event) => {
            // prevent click if dragging the indicator
            if (event.target === viewportIndicator) return;

            const miniRect = miniatureContainer.getBoundingClientRect();
            const clickX = event.clientX - miniRect.left;
            const clickY = event.clientY - miniRect.top;

            const mainBounds = getMainERDBounds();
            const targetX = mainBounds.x + (clickX / miniRect.width) * mainBounds.width;
            const targetY = mainBounds.y + (clickY / miniRect.height) * mainBounds.height;

            zoomToPoint(targetX, targetY);
        });
    }

    svg.addEventListener('mousedown', (event) => {
        if (event.button !== 0 ||
            event.target.closest('.metadata-box, .miniature-box, .instructions') ||
            event.target.id === 'overlay-container' ||
            event.target.closest('.node') ||
            event.target.closest('.edge')) {
            return;
        }
        mouseDownStartX = event.clientX;
        mouseDownStartY = event.clientY;
        startX = event.clientX;
        startY = event.clientY;
        event.preventDefault();
    });

    // Global mouse move for both panning and indicator dragging
    window.addEventListener('mousemove', (event) => {
        // Check if we should start panning (after drag threshold)
        if (!isPanning && mouseDownStartX !== undefined && mouseDownStartY !== undefined) {
            const dx = Math.abs(event.clientX - mouseDownStartX);
            const dy = Math.abs(event.clientY - mouseDownStartY);
            if (dx > dragThreshold || dy > dragThreshold) {
                isPanning = true;
                svg.classList.add('grabbing');
            }
        }

        if (isPanning) {
            event.preventDefault();
            const dx = event.clientX - startX;
            const dy = event.clientY - startY;
            userTx += dx / (userS * initialS);
            userTy += dy / (userS * initialS);
            startX = event.clientX;
            startY = event.clientY;
            applyTransform();
        } else if (isDraggingIndicator) {
            event.preventDefault();
            const dx = event.clientX - indicatorStartX;
            const dy = event.clientY - indicatorStartY;

            const miniRect = miniatureContainer.getBoundingClientRect();
            const mainBounds = getMainERDBounds();

            if (miniRect.width > 0 && miniRect.height > 0) {
                const panX = (dx / miniRect.width) * mainBounds.width;
                const panY = (dy / miniRect.height) * mainBounds.height;

                // Calculate the visible area in main coordinates
                const ctm = mainGroup.getScreenCTM();
                if (!ctm) return;
                const invCtm = ctm.inverse();

                const pt1 = svg.createSVGPoint();
                pt1.x = 0;
                pt1.y = 0;
                const svgPt1 = pt1.matrixTransform(invCtm);

                const pt2 = svg.createSVGPoint();
                pt2.x = window.innerWidth;
                pt2.y = window.innerHeight;
                const svgPt2 = pt2.matrixTransform(invCtm);

                const visibleWidth = svgPt2.x - svgPt1.x;
                const visibleHeight = svgPt2.y - svgPt1.y;

                // Clamp so the viewport indicator stays inside the minimap
                let newUserTx = userTx - panX / initialS;
                let newUserTy = userTy - panY / initialS;

                // Calculate the min/max allowed pan so the viewport stays inside
                const minTx = -(svgPt1.x - mainBounds.x) / initialS;
                const maxTx = (mainBounds.width - visibleWidth - (svgPt1.x - mainBounds.x)) / initialS;
                const minTy = -(svgPt1.y - mainBounds.y) / initialS;
                const maxTy = (mainBounds.height - visibleHeight - (svgPt1.y - mainBounds.y)) / initialS;

                // Clamp the new values
                newUserTx = Math.max(minTx, Math.min(maxTx, newUserTx));
                newUserTy = Math.max(minTy, Math.min(maxTy, newUserTy));

                userTx = newUserTx;
                userTy = newUserTy;

                applyTransform();
            }

            indicatorStartX = event.clientX;
            indicatorStartY = event.clientY;
        }
    });

    const endPan = () => {
        if (isPanning) {
            isPanning = false;
            svg.classList.remove('grabbing');
        }
        if (isDraggingIndicator) {
            isDraggingIndicator = false;
            viewportIndicator.classList.remove('dragging');
        }
        // Reset mouse tracking variables
        mouseDownStartX = undefined;
        mouseDownStartY = undefined;
    };

    window.addEventListener('mouseup', endPan);
    window.addEventListener('mouseleave', endPan);
    const zoomIntensity = 0.1;
    const maxZoomOut = 0.1; // Can zoom out to 20%
    const maxZoomIn = 5;   // Can zoom in to 500%


    // Handle mouse wheel for zooming
    svg.addEventListener('wheel', (event) => {
        event.preventDefault();
        const dir = event.deltaY < 0 ? 1 : -1;
        const scaleAmount = 1 + dir * zoomIntensity;

        let newS = userS * scaleAmount;
        // Clamp the zoom level
        newS = Math.max(maxZoomOut, Math.min(maxZoomIn, newS));

        // Get mouse position in the main group's coordinate system to zoom towards it
        const pt = svg.createSVGPoint();
        pt.x = event.clientX;
        pt.y = event.clientY;
        const svgP = pt.matrixTransform(mainGroup.getScreenCTM().inverse());

        // Update user transform to zoom towards the mouse pointer
        userTx -= (svgP.x * (newS - userS)) / initialS;
        userTy -= (svgP.y * (newS - userS)) / initialS;
        userS = newS;

        applyTransform();
    }, { passive: false });

    // Handle reset keys
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' || e.key.toLowerCase() === 'r') {
            resetZoom();
        }
    });

    // Handle window scroll and resize to keep UI fixed
    window.addEventListener('scroll', onViewportChange, { passive: true });
    window.addEventListener('resize', onViewportChange, { passive: true });


    requestAnimationFrame(() => {
        const mainBounds = getMainERDBounds();
        const centerX = mainBounds.x + mainBounds.width / 2;
        const centerY = mainBounds.y + mainBounds.height / 2;
        zoomToPoint(centerX, centerY, maxZoomOut);
    });
});

]]></script>
</svg>
